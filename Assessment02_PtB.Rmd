---
title: "Assessment02_pt_b"
author: "Xilin Huang Liam"
date: "20/09/2021"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Data loading: 
Before we starting working on building models and analysis, data need to be loaded from Yahoo Finance API and Tweet count from Kaggle API. In our project, we will be collecting:
Coins (to US dollar)

* BTC-USD: Bitcoin

* ETH-USD: Ethereum

* ADA-USD: Cardano

* DOGE-USD: Dogecoin

* SHIB-USD: Shiba Inu coin

Index

* ^DJI: Dow Jones Industrial

* ^IXIC: Nasdaq Composite

* ^GSPC: S&P 500

* GC=F: Gold

Stocks

* TSLA: Tesla

* GOOG: Google

* AAPL: Apple

* NVDA: Nvidia

* AMD: Advanced Micro Devices

* TSM: Taiwan Semiconductor Manufacturing

Tweet count

* Tweet_volume: number of #bitcoin tweeted

All the data will be saved as `xts` (Extensible Time Series) object.

## Loading Tweet data from Kaggle
```{r}
# incorporate tweet volume data prepared by Huy
rm(list=ls())
install.packages(c("devtools"))
devtools::install_github("ldurazo/kaggler")
library(readr)
library(kaggler)

kgl_auth(creds_file = 'kaggle.json')
response <- kgl_datasets_download_all(owner_dataset = "kaushiksuresh147/bitcoin-tweets")
download.file(response[1]$url, "temp.zip", mode="wb")
unzip_result <- unzip("temp.zip")

```


```{r}

#install.packages(c("zoo","xts","TTR","quantmod","tidytext","textdata","rvest"))
library(tidyverse)
library(lubridate)
library(tidytext)
library(textdata)
library(rvest)
```


```{r}

path = "https://bitinfocharts.com/comparison/decred-tweets.html#1y"
scripts <- read_html(path, encoding = 'utf8') %>%
  html_nodes("script") %>% html_text(trim=TRUE)

# filter special characters, get date and tweet volume only
text <- scripts[5]
new <- strsplit(text, '\\[\\[')[[1]][[2]]
new2 <- strsplit(new, '\\]\\]')[[1]][[1]]

new3 <- str_replace_all(new2, 'new Date\\(', '')  %>%
  str_replace_all('\\[', '') %>%
  str_replace_all('"', '') %>%
  str_replace_all('\\]', '') %>%
  str_replace_all('\\)', '')  

new4 <- strsplit(new3, ',')

# convert list of list into dataframe. Sample input ['2020/05/09',59,...]
table <- as.data.frame(unlist(new4))

# dataframe now contains only 1 columns, subsetting odd and even rows to split into 2 columns

tweet_volume =  data.frame(date = table[c(TRUE,FALSE),], tweet_count = table[c(FALSE,TRUE),])

# tweet counts is reported as thousands of tweet, here convert it to normal number
tweet_volume$tweet_count <- as.numeric(tweet_volume$tweet_count)*1000
tweet_volume$date <- as_date(tweet_volume$date)

write.csv(tweet_volume,"tweet_volume.csv") #in case failed to download the data
```

## Loading data from Yahoo Finance

```{r yahoo, message=FALSE, warning=FALSE}
library(zoo)
library(xts)
library(TTR)
library(quantmod)

coin_portfolio=c("BTC-USD","ETH-USD","ADA-USD",
                 "DOGE-USD","SHIB-USD")
index_portfolio=c("^DJI","^IXIC","^GSPC","GC=F")
stock_portfolio=c("TSLA","GOOG","AAPL","NVDA","AMD","TSM")

data <- getSymbols(c(coin_portfolio,
                     index_portfolio,
                     stock_portfolio),
                   src='yahoo',
                   from="2019-12-08",
                   #to=d,
                   autoassign=FALSE)
```

## Simple linear regression in finance data
For simple linear regression, we will use TSLA - Bitcoin as example. Since this project will be focusing on performing linear regression models, the data will be transformed from `xts` object to `dataframe`. Other data will be transformed to dataframes for multi-linear model analysis based on the result of TSLA - Bitcoin.

```{r data}
df_BTC = data.frame(date=index(`BTC-USD`), coredata(`BTC-USD`))
df_TSLA = data.frame(date=index(TSLA), coredata(TSLA))
# coins
df_ETH = data.frame(date=index(`ETH-USD`), coredata(`ETH-USD`))
df_ADA = data.frame(date=index(`ADA-USD`), coredata(`ADA-USD`))
df_DOGE = data.frame(date=index(`DOGE-USD`), coredata(`DOGE-USD`))
df_SHIB = data.frame(date=index(`SHIB-USD`), coredata(`SHIB-USD`))
# indices
df_DJI = data.frame(date=index(DJI), coredata(DJI))
df_IXIC = data.frame(date=index(IXIC), coredata(IXIC))
df_GSPC = data.frame(date=index(GSPC), coredata(GSPC))
df_GOLD = data.frame(date=index(`GC=F`), coredata(`GC=F`))
# stock
df_GOOG = data.frame(date=index(GOOG), coredata(GOOG))
df_AAPL = data.frame(date=index(AAPL), coredata(AAPL))
df_NVDA = data.frame(date=index(NVDA), coredata(NVDA))
df_AMD = data.frame(date=index(AMD), coredata(AMD))
df_TSM = data.frame(date=index(TSM), coredata(TSM))
# tweet
df_tweet = tweet_volume

```

##EDA

```{r}
# merge all data into one dataset
df_eda <- merge(df_BTC, df_TSLA, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_ETH, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_ADA, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_DOGE, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_SHIB, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_DJI, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_IXIC, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_GSPC, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_GOLD, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_GOOG, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_AAPL, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_NVDA, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_AMD, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_TSM, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_tweet, by = 'date', all.x = TRUE)
df_eda <- df_eda[,c(1,5,11,17,23,29,35,41,47,53,59,65,71,77,83,89,92)]
```

```{r}
library(DataExplorer)
str(df_eda)
introduce(df_eda)
plot_intro(df_eda)
plot_missing(df_eda)
```


#clean name of df_eda
library(janitor)
df_eda = clean_names(df_eda)
names(df_eda)

```{r}
#drop df_SHIB due high missing 
drop = c("SHIB.USD.Close")

df_eda <- df_eda %>% 
  select(-one_of(drop))

plot_intro(df_eda)
plot_missing(df_eda)
```


```{r}
#drop df_SHIB due high missing 
min(df_ADA$date) # ADA has been publicly listed since 2017-10-1
min(df_tweet$date) # Data soucred from Kaggles is more complete after 2019-01-01

# subset the data from 2019-0-01
df_eda = subset(df_eda, date >'2018-12-31')
plot_intro(df_eda)
plot_missing(df_eda)
```

```{r}
# the 31.5% of missing obervsation is resulted from the non-trading data for the stock market in the weekend while cryptocurrencies do not rest in the holidays.  In that case,, the dataset shall be adjusted to trading date instead of calendar day for this research. 

df_eda = na.omit(df_eda)

```

```{r}
plot_boxplot(df_eda, by="BTC.USD.Close")

```

```{r}
plot_histogram(df_eda)

```

```{r}
plot_qq(df_eda)
```


```{r}
plot_correlation(na.omit(df_eda),type="c")

```


```{r friday_filled, message=FALSE, warning=FALSE}
library(tidyr)
# use Friday's data for weekends
df_sub <- merge(df_BTC, df_ETH, by = 'date', all.x = TRUE)
df_sub <- merge(df_sub, df_IXIC, by = 'date', all.x = TRUE)
df_sub <- merge(df_sub, df_GOLD, by = 'date', all.x = TRUE)
df_sub <- merge(df_sub, df_TSM, by = 'date', all.x = TRUE)

#df_sub_filled <- df_sub %>% fill()
```

```{r 2019, message=FALSE, warning=FALSE}
# subset data (close price)
df_sub <- subset(na.omit(df_sub),
                 #date >= '2019-01-01',
                 select = c(date,
                            BTC.USD.Close,
                            ETH.USD.Close,
                            GC.F.Close,
                            IXIC.Close,
                            TSM.Close
                            )
                 )
row.names(df_sub) <- NULL
```

```{r lag_data, message=FALSE, warning=FALSE}
library(dplyr)
lag_list = c(1, 5, 10, 20, 40, 60) # needs research

for (i in lag_list){
  if (i == lag_list[1]) {
    df_BTC_TDlag = data.frame(col1 = lag(df_sub$BTC.USD.Close, n = i))
    names(df_BTC_TDlag)[ncol(df_BTC_TDlag)] <- paste0("BTC_TDlag_", i)
  } else {
    df_BTC_TDlag[,ncol(df_BTC_TDlag)+1] <- lag(df_sub$BTC.USD.Close, n = i)
    names(df_BTC_TDlag)[ncol(df_BTC_TDlag)] <- paste0("BTC_TDlag_", i)
  }
}

for (i in lag_list){
  if (i == lag_list[1]) {
    df_ETH_TDlag = data.frame(col1 = lag(df_sub$ETH.USD.Close, n = i))
    names(df_ETH_TDlag)[ncol(df_ETH_TDlag)] <- paste0("ETH_TDlag_", i)
  } else {
    df_ETH_TDlag[,ncol(df_ETH_TDlag)+1] <- lag(df_sub$ETH.USD.Close, n = i)
    names(df_ETH_TDlag)[ncol(df_ETH_TDlag)] <- paste0("ETH_TDlag_", i)
  }
}

for (i in lag_list){
  if (i == lag_list[1]) {
    df_IXIC_TDlag = data.frame(col1 = lag(df_sub$IXIC.Close, n = i))
    names(df_IXIC_TDlag)[ncol(df_IXIC_TDlag)] <- paste0("IXIC_TDlag_", i)
  } else {
    df_IXIC_TDlag[,ncol(df_IXIC_TDlag)+1] <- lag(df_sub$IXIC.Close, n = i)
    names(df_IXIC_TDlag)[ncol(df_IXIC_TDlag)] <- paste0("IXIC_TDlag_", i)
  }
}

for (i in lag_list){
  if (i == lag_list[1]) {
    df_GOLD_TDlag = data.frame(col1 = lag(df_sub$GC.F.Close, n = i))
    names(df_GOLD_TDlag)[ncol(df_GOLD_TDlag)] <- paste0("GOLD_TDlag_", i)
  } else {
    df_GOLD_TDlag[,ncol(df_GOLD_TDlag)+1] <- lag(df_sub$GC.F.Close, n = i)
    names(df_GOLD_TDlag)[ncol(df_GOLD_TDlag)] <- paste0("GOLD_TDlag_", i)
  }
}

for (i in lag_list){
  if (i == lag_list[1]) {
    df_TSM_TDlag = data.frame(col1 = lag(df_sub$TSM.Close, n = i))
    names(df_TSM_TDlag)[ncol(df_TSM_TDlag)] <- paste0("TSM_TDlag_", i)
  } else {
    df_TSM_TDlag[,ncol(df_TSM_TDlag)+1] <- lag(df_sub$TSM.Close, n = i)
    names(df_TSM_TDlag)[ncol(df_TSM_TDlag)] <- paste0("TSM_TDlag_", i)
  }
}
```

```{r lag_data_merge, echo=TRUE}
df_selected <- cbind(df_sub, df_BTC_TDlag)
df_selected <- cbind(df_selected, df_ETH_TDlag)
df_selected <- cbind(df_selected, df_IXIC_TDlag)
df_selected <- cbind(df_selected, df_GOLD_TDlag)
df_selected <- cbind(df_selected, df_TSM_TDlag)
```

```{r return_data, echo=TRUE, message=FALSE}
# Bitcoin daily return
BDReturn <- c(NA, diff(df_selected$BTC.USD.Close)/df_selected$BTC.USD.Close*100)
BDReturn <- BDReturn[-length(BDReturn)]
df_selected$BTC_Return <- BDReturn
```

```{r lm_model_log, echo=TRUE, warning=FALSE}
library(ggplot2)
library(ggfortify)
# Best result at 90 lag days -- log(y) ~ x
x_value1 = log(df_selected$ETH_TDlag_1)
y_value1 = log(df_selected$BTC.USD.Close)
fit1 = lm(data = df_selected, y_value1 ~ x_value1)
summary(fit1)
ggplot(df_selected, aes(x = x_value1, y = y_value1)) +
  geom_point() +
  xlab("log ETH 1 trading days lag") + 
  ylab("log Bitcoin closing") + 
  stat_smooth(method = 'lm', col = 'red') + 
  labs(title = paste("Adj R2=", signif(summary(fit1)$adj.r.squared, 5),
                     "Inc=", signif(fit1$coef[[1]], 5),
                     "Slp=", signif(fit1$coef[[2]], 5),
                     "P=", signif(summary(fit1)$coef[2,4], 5)
                     )
       )
```
```{r lm_model_log_plots, echo=TRUE, warning=FALSE}
autoplot(fit1)
```

```{r correlation_matrix, warning=FALSE}
library(corrplot)
df_selected_cor <- cor(subset(df_selected, select = -c(date, 
                                                       BTC_TDlag_1,
                                                       BTC_TDlag_5,
                                                       BTC_TDlag_10,
                                                       BTC_TDlag_20,
                                                       BTC_TDlag_40,
                                                       BTC_TDlag_60)
                              ),
                       use="pairwise.complete.obs")
#corrplot(df_selected_cor, method="pie")
corrplot(df_selected_cor, method="number")
```

```{r others}
# coins data frame
df_coin = data.frame()
df_coin = merge(df_BTC, df_ETH, by = 'date', all.x = TRUE)
df_coin = merge(df_coin, df_ADA, by = 'date', all.x = TRUE)
df_coin = merge(df_coin, df_DOGE, by = 'date', all.x = TRUE)
df_coin = merge(df_coin, df_SHIB, by = 'date', all.x = TRUE)
# indexes data frame
df_index = data.frame()
df_index = merge(df_DJI, df_IXIC, by = 'date', all.x = TRUE)
df_index = merge(df_index, df_GSPC, by = 'date', all.x = TRUE)
df_index = merge(df_index, df_GOLD, by = 'date', all.x = TRUE)
# stocks data frame
df_stock = data.frame()
df_stock = merge(df_TSLA, df_GOOG, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_AAPL, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_NVDA, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_AMD, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_TSM, by = 'date', all.x = TRUE)
# merge 3 portfolios data frame
df_port = data.frame()
df_port = merge(df_coin, df_index, by = 'date', all.x = TRUE)
df_port = merge(df_port, df_stock, by = 'date', all.x = TRUE)

# subset
df_port <- subset(df_port,
                  #date >= '2019-01-01',
                  select = c(date, 
                             BTC.USD.Close, 
                             BTC.USD.Volume,
                             ETH.USD.Close, 
                             ETH.USD.Volume,
                             ADA.USD.Close, 
                             ADA.USD.Volume,
                             DOGE.USD.Close, 
                             DOGE.USD.Volume,
                             SHIB.USD.Close, 
                             SHIB.USD.Volume,
                             DJI.Close, 
                             DJI.Volume,
                             IXIC.Close, 
                             IXIC.Volume,
                             GSPC.Close, 
                             GSPC.Volume,
                             GC.F.Close, 
                             GC.F.Volume,
                             TSLA.Close, 
                             TSLA.Volume,
                             GOOG.Close, 
                             GOOG.Volume,
                             AAPL.Close, 
                             AAPL.Volume,
                             NVDA.Close, 
                             NVDA.Volume,
                             AMD.Close, 
                             AMD.Volume,
                             TSM.Close, 
                             TSM.Volume
                             )
                  )
row.names(df_port) <- NULL


df_port_price <- subset(df_port,
                        select = c(date, 
                                   BTC.USD.Close, 
                                   ETH.USD.Close, 
                                   ADA.USD.Close, 
                                   DOGE.USD.Close, 
                                   SHIB.USD.Close, 
                                   DJI.Close,                       
                                   IXIC.Close, 
                                   GSPC.Close, 
                                   GC.F.Close, 
                                   TSLA.Close, 
                                   GOOG.Close, 
                                   AAPL.Close, 
                                   NVDA.Close, 
                                   AMD.Close, 
                                   TSM.Close
                                   )
                        )

df_port_price_cor <- cor(subset(df_port_price, select = -c(date)), use="pairwise.complete.obs")
corrplot(df_port_price_cor, method="number")
```

```{r multi_linear}
#m_fit <- lm(`BTC.USD.Close` ~ . -date,
#            data = df_port_price)
#summary(m_fit)
```

```{r multi_linear_stars}
#m_fit_adjusted <- lm(`BTC.USD.Close` ~ 
#                       `BTC.USD.Volume` + 
#                       `ETH.USD.Close` + 
#                       `ETH.USD.Volume` + 
#                       `DOGE.USD.Close` +
#                       `GC.F.Close`,
#                     data = df_port)
#summary(m_fit_adjusted)
# R squared
#signif(summary(m_fit_adjusted)$adj.r.squared, 5)
```
```{r multi_linear_stars_f}
#m_fit_adjusted_filtered <- lm(`BTC.USD.Close` ~ 
#                                `BTC.USD.Volume` +
#                                `ETH.USD.Close` + 
#                                `DOGE.USD.Close`,
#                              data = df_port)
#summary(m_fit_adjusted_filtered)
# R squared
#signif(summary(m_fit_adjusted_filtered)$adj.r.squared, 5)
```

```{r SLR_sampling}
# sampling train, validation and test sets (if using stepwise this step could be ignored)
trainset_size <- floor(0.7 * nrow(df_port_price))
validation_size <- floor(0.1 * nrow(df_port_price))
testset_size <- floor(0.2 * nrow(df_port_price))
set.seed(2)
trainset_indices <- sample(seq_len(nrow(df_port_price)), size = trainset_size)
trainset <- df_port_price[trainset_indices, ]
df_set <- df_port_price[-trainset_indices, ]
testset_indices <- sample(seq_len(nrow(df_set)), size = testset_size)
testset <- df_set[testset_indices, ]
validationset <- df_set[-testset_indices,]
```

```{r SLR_TSLA_modelling}
lm_TSLA = lm(formula = BTC.USD.Close ~ TSLA.Close, data = trainset)
summary(lm_TSLA)

testset_selected <- subset(testset, select=c(TSLA.Close,
                                             BTC.USD.Close))
ggplot(trainset, aes(x=TSLA.Close, y=BTC.USD.Close)) + 
  geom_point() + 
  geom_point(data=testset_selected,colour='red') + 
  stat_smooth(method = 'lm', col = 'black') 
```

```{r stepwise_leaps}
#library(leaps)
#models <- regsubsets(BTC.USD.Close ~.,
#                     data = subset(trainset, select=-(date)),
#                     nvmax = 8,
#                     method = "seqrep")
#summary(models)
```
```{r cor}
df_selected_cor <- cor(subset(df_selected, select = -c(date,
#                                                    BTC_TDlag_1,
#                                                    BTC_TDlag_5,
#                                                    BTC_TDlag_10, 
#                                                    BTC_TDlag_20,
#                                                    BTC_TDlag_40,
#                                                    BTC_TDlag_60,
                                                    ETH.USD.Close,
                                                    IXIC.Close,
                                                    GC.F.Close,
                                                    TSM.Close,
                                                    BTC_Return)), use="pairwise.complete.obs")
corrplot(df_selected_cor,method="number")
```
```{r stepwise_caret}
library(caret)
train.control <- trainControl(method = "cv", number = 5, p = 0.7)
df_selected_test <- df_selected[df_selected['date'] >= '2021-09-01',]
df_selected_train <- df_selected[df_selected['date'] < '2021-09-01',]
# use the data without volume
step.model <- train(BTC.USD.Close ~.,
                    data = na.omit(subset(df_selected_train,
                                          select=c(BTC.USD.Close,
                                                   BTC_TDlag_1,
                                                   ETH_TDlag_1,
                                                   IXIC_TDlag_5,
                                                   GOLD_TDlag_60,
                                                   TSM_TDlag_40)
                                         )
                                 ),
                    method = "leapSeq",#"leapBackward", #"leapSeq", #"leapForward",
                    tuneGrid = data.frame(nvmax = 1:5),
                    trControl = train.control
                    )

step.model
summary(step.model$finalModel)
step.model$bestTune
#step.model$bestTune
coef(step.model$finalModel, 3)

besttune_lm <- train(BTC.USD.Close ~. -IXIC_TDlag_5 -GOLD_TDlag_60,
                    data = na.omit(subset(df_selected_train,
                                          select=c(BTC.USD.Close,
                                                   BTC_TDlag_1,
                                                   ETH_TDlag_1,
                                                   IXIC_TDlag_5,
                                                   GOLD_TDlag_60,
                                                   TSM_TDlag_40)
                                         )
                                   ),
                    method = "lm",
                    trControl = train.control
                    )
coef(besttune_lm$finalModel)
car::vif(besttune_lm$finalModel) #greedy algorithm

deviance(besttune_lm$finalModel) #compare SSE every elimination

summary(besttune_lm)

prediction <- predict(besttune_lm$finalModel, df_selected_test)
# RMSE
RMSE = sqrt(mean((prediction - df_selected_test$BTC.USD.Close)^2, na.rm = TRUE))

RMSE/(mean(df_selected_test$BTC.USD.Close))

autoplot(besttune_lm$finalModel)
```
                                          select=-c(date,
                                                    BTC_TDlag_1,
                                                    BTC_TDlag_5,
                                                    BTC_TDlag_10, 
                                                    BTC_TDlag_20,
                                                    BTC_TDlag_40,
                                                    BTC_TDlag_60,
                                                    ETH.USD.Close,
                                                    IXIC.Close,
                                                    GC.F.Close,
                                                    TSM.Close,
                                                    BTC_Return
                                                   )
```{r elimination}
besttune_lm <- train(BTC.USD.Close ~ ETH_TDlag_1 + 
                       ETH_TDlag_10 + 
                       ETH_TDlag_20 +
                       ETH_TDlag_60 +
                       GOLD_TDlag_20 +
                       TSM_TDlag_20 +
                       TSM_TDlag_40 +
                       TSM_TDlag_60,
                    data = na.omit(df_selected_train),
                    method = "lm",
                    trControl = train.control
                    )
coef(besttune_lm$finalModel)

car::vif(besttune_lm$finalModel) #greedy algorithm

deviance(besttune_lm$finalModel) #compare SSE every elimination
```


# Not in used
```{r stepwise_MASS}
library(MASS)
full.model <- lm(BTC.USD.Close ~., data = na.omit(subset(df_selected,
                                                         select=-c(date,
                                                                   BTC_TDlag_1,
                                                                   BTC_TDlag_5,
                                                                   BTC_TDlag_10,
                                                                   BTC_TDlag_20,
                                                                   BTC_TDlag_40,
                                                                   BTC_TDlag_60)
                                                         )
                                                  )
)
step.model <- stepAIC(full.model, direction = "both", 
                      trace = FALSE)
summary(step.model)
```

```{r stepwise_MASS_caret}
# Train the model
step.model <- train(BTC.USD.Close ~., data = na.omit(trainset),
                    method = "lmStepAIC", 
                    trControl = train.control,
                    trace = FALSE
                    )
# Model accuracy
step.model$results
# Final model coefficients
step.model$finalModel
# Summary of the model
summary(step.model$finalModel)
```

