---
title: "Assessment02_pt_b"
author: "Xilin Huang Liam"
date: "20/09/2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Data loading: 
Before we starting working on building models and analysis, data need to be loaded from Yahoo Finance API and Tweet count from Kaggle API. In our project, we will be collecting:
Coins (to US dollar)

* BTC-USD: Bitcoin

* ETH-USD: Ethereum

* ADA-USD: Cardano

* DOGE-USD: Dogecoin

* SHIB-USD: Shiba Inu coin

Index

* ^DJI: Dow Jones Industrial

* ^IXIC: Nasdaq Composite

* ^GSPC: S&P 500

* GC=F: Gold

Stocks

* TSLA: Tesla

* GOOG: Google

* AAPL: Apple

* NVDA: Nvidia

* AMD: Advanced Micro Devices

* TSM: Taiwan Semiconductor Manufacturing

Tweet count

* Tweet_volume: number of #bitcoin tweeted

All the data will be saved as `xts` (Extensible Time Series) object.

## Loading Tweet data from Kaggle
```{r}
# incorporate tweet volume data prepared by Huy
rm(list=ls())
install.packages(c("devtools"))
devtools::install_github("ldurazo/kaggler")
library(readr)
library(kaggler)

kgl_auth(creds_file = 'kaggle.json')
response <- kgl_datasets_download_all(owner_dataset = "kaushiksuresh147/bitcoin-tweets")
download.file(response[1]$url, "temp.zip", mode="wb")
unzip_result <- unzip("temp.zip")

```


```{r}

#install.packages(c("zoo","xts","TTR","quantmod","tidytext","textdata","rvest"))
library(tidyverse)
library(lubridate)
library(tidytext)
library(textdata)
library(rvest)
```


```{r}

path = "https://bitinfocharts.com/comparison/decred-tweets.html#1y"
scripts <- read_html(path, encoding = 'utf8') %>%
  html_nodes("script") %>% html_text(trim=TRUE)

# filter special characters, get date and tweet volume only
text <- scripts[5]
new <- strsplit(text, '\\[\\[')[[1]][[2]]
new2 <- strsplit(new, '\\]\\]')[[1]][[1]]

new3 <- str_replace_all(new2, 'new Date\\(', '')  %>%
  str_replace_all('\\[', '') %>%
  str_replace_all('"', '') %>%
  str_replace_all('\\]', '') %>%
  str_replace_all('\\)', '')  

new4 <- strsplit(new3, ',')

# convert list of list into dataframe. Sample input ['2020/05/09',59,...]
table <- as.data.frame(unlist(new4))

# dataframe now contains only 1 columns, subsetting odd and even rows to split into 2 columns

tweet_volume =  data.frame(date = table[c(TRUE,FALSE),], tweet_count = table[c(FALSE,TRUE),])

# tweet counts is reported as thousands of tweet, here convert it to normal number
tweet_volume$tweet_count <- as.numeric(tweet_volume$tweet_count)*1000
tweet_volume$date <- as_date(tweet_volume$date)

write.csv(tweet_volume,"tweet_volume.csv") #in case failed to download the data
```

## Loading data from Yahoo Finance

```{r yahoo, message=FALSE, warning=FALSE}
library(zoo)
library(xts)
library(TTR)
library(quantmod)

coin_portfolio=c("BTC-USD","ETH-USD","ADA-USD",
                 "DOGE-USD","SHIB-USD")
index_portfolio=c("^DJI","^IXIC","^GSPC","GC=F")
stock_portfolio=c("TSLA","GOOG","AAPL","NVDA","AMD","TSM")

data <- getSymbols(c(coin_portfolio,
                     index_portfolio,
                     stock_portfolio),
                   src='yahoo',
                   #from=dyear,
                   #to=d,
                   autoassign=FALSE)
```

## Simple linear regression in finance data
For simple linear regression, we will use TSLA - Bitcoin as example. Since this project will be focusing on performing linear regression models, the data will be transformed from `xts` object to `dataframe`. Other data will be transformed to dataframes for multi-linear model analysis based on the result of TSLA - Bitcoin.

```{r data}
df_BTC = data.frame(date=index(`BTC-USD`), coredata(`BTC-USD`))
df_TSLA = data.frame(date=index(TSLA), coredata(TSLA))
# coins
df_ETH = data.frame(date=index(`ETH-USD`), coredata(`ETH-USD`))
df_ADA = data.frame(date=index(`ADA-USD`), coredata(`ADA-USD`))
df_DOGE = data.frame(date=index(`DOGE-USD`), coredata(`DOGE-USD`))
df_SHIB = data.frame(date=index(`SHIB-USD`), coredata(`SHIB-USD`))
# indices
df_DJI = data.frame(date=index(DJI), coredata(DJI))
df_IXIC = data.frame(date=index(IXIC), coredata(IXIC))
df_GSPC = data.frame(date=index(GSPC), coredata(GSPC))
df_GOLD = data.frame(date=index(`GC=F`), coredata(`GC=F`))
# stock
df_GOOG = data.frame(date=index(GOOG), coredata(GOOG))
df_AAPL = data.frame(date=index(AAPL), coredata(AAPL))
df_NVDA = data.frame(date=index(NVDA), coredata(NVDA))
df_AMD = data.frame(date=index(AMD), coredata(AMD))
df_TSM = data.frame(date=index(TSM), coredata(TSM))
# tweet
df_tweet = tweet_volume

```

##EDA

```{r}
# merge all data into one dataset
df_eda <- merge(df_BTC, df_TSLA, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_ETH, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_ADA, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_DOGE, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_SHIB, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_DJI, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_IXIC, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_GSPC, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_GOLD, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_GOOG, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_AAPL, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_NVDA, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_AMD, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_TSM, by = 'date', all.x = TRUE)
df_eda <- merge(df_eda, df_tweet, by = 'date', all.x = TRUE)
df_eda <- df_eda[,c(1,5,11,17,23,29,35,41,47,53,59,65,71,77,83,89,92)]
```

```{r}
library(DataExplorer)
str(df_eda)
introduce(df_eda)
plot_intro(df_eda)
plot_missing(df_eda)
```


#clean name of df_eda
library(janitor)
df_eda = clean_names(df_eda)
names(df_eda)

```{r}
#drop df_SHIB due high missing 
drop = c("SHIB.USD.Close")

df_eda <- df_eda %>% 
  select(-one_of(drop))

plot_intro(df_eda)
plot_missing(df_eda)
```


```{r}
#drop df_SHIB due high missing 
min(df_ADA$date) # ADA has been publicly listed since 2017-10-1
min(df_tweet$date) # Data soucred from Kaggles is more complete after 2019-01-01

# subset the data from 2019-0-01
df_eda = subset(df_eda, date >'2018-12-31')
plot_intro(df_eda)
plot_missing(df_eda)
```
```{r}
# the 31.5% of missing obersation is resulted from the non-trading data for the stock market in the weekend while cryptocurrencies do not rest in the holidays.  In that case,, the dataset shall be adjusted to trading date instead of calendar day for this research. 



```

```{r}
plot_boxplot(df_eda, by="BTC.USD.Close")

```

```{r}
plot_histogram(df_eda)

```
```{r}
plot_qq(df_eda)
```


```{r}
plot_correlation(na.omit(df_eda),type="c")

```


```{r friday_filled, message=FALSE, warning=FALSE}
library(tidyr)
# use Friday's data for weekends
df_BTCTSLA <- merge(df_BTC, df_TSLA, by = 'date', all.x = TRUE)
df_BTCTSLA_filled <- df_BTCTSLA %>%
fill(TSLA.Open,TSLA.High,TSLA.Low,TSLA.Close,TSLA.Adjusted,TSLA.Volume)
```

```{r 2019, message=FALSE, warning=FALSE}
# subset data (2019, close price and volume)
df_BTCTSLA_sub <- subset(df_BTCTSLA_filled,
                         date >= '2019-01-01',
                         select = c(date,
                                    TSLA.Close,
                                    TSLA.Volume,
                                    BTC.USD.Close,
                                    BTC.USD.Volume))
row.names(df_BTCTSLA_sub) <- NULL
```

```{r lag_data, message=FALSE, warning=FALSE}
library(dplyr)
lag_list = c(1, 3, 5, 10, 30, 60, 90)
for (i in lag_list){
  if (i == lag_list[1]) {
    df_BTCTSLA_lag = data.frame(col1 = lag(df_BTCTSLA_sub$TSLA.Close, n = i))
    names(df_BTCTSLA_lag)[ncol(df_BTCTSLA_lag)] <- paste0("TSLA_lag_", i)
  } else {
    df_BTCTSLA_lag[,ncol(df_BTCTSLA_lag)+1] <- lag(df_BTCTSLA_sub$TSLA.Close, n = i)
    names(df_BTCTSLA_lag)[ncol(df_BTCTSLA_lag)] <- paste0("TSLA_lag_", i)
  }
}
```

```{r lag_data_merge, echo=TRUE}
df_BTCTSLA_lag_m <- cbind(df_BTCTSLA_sub, df_BTCTSLA_lag)
```

```{r return_data, echo=TRUE, message=FALSE}
# Bitcoin daily return
BDReturn <- c(NA, diff(df_BTCTSLA_lag_m$BTC.USD.Close)/df_BTCTSLA_lag_m$BTC.USD.Close*100)
BDReturn <- BDReturn[-length(BDReturn)]
df_BTCTSLA_lag_m$BTC_Return <- BDReturn
# TSLA daily return
TDReturn <- c(NA, diff(df_BTCTSLA_lag_m$TSLA.Close)/df_BTCTSLA_lag_m$TSLA.Close*100)
TDReturn <- TDReturn[-length(TDReturn)]
df_BTCTSLA_lag_m$TSLA_Return <- TDReturn
```

```{r lm_model_log, echo=TRUE, warning=FALSE}
library(ggplot2)
library(ggfortify)
# Best result at 90 lag days -- log(y) ~ x
x_value1 = df_BTCTSLA_lag_m$TSLA_lag_90
y_value1 = log(df_BTCTSLA_lag_m$BTC.USD.Close)
fit1 = lm(data = df_BTCTSLA_lag_m, y_value1 ~ x_value1)
summary(fit1)
ggplot(df_BTCTSLA_lag_m, aes(x = x_value1, y = y_value1)) +
  geom_point() +
  xlab("TSLA 90 days lag") + 
  ylab("log(Bitcoin closing)") + 
  stat_smooth(method = 'lm', col = 'red') + 
  labs(title = paste("Adj R2=", signif(summary(fit1)$adj.r.squared, 5),
                     "Inc=", signif(fit1$coef[[1]], 5),
                     "Slp=", signif(fit1$coef[[2]], 5),
                     #"P=", signif(summary(fit1)$coef[2,4], 5),
                     "RSE=", sigma(fit1)/mean(df_BTCTSLA_lag_m$BTC.USD.Close, na.rm=TRUE)))
```
```{r lm_model_log_plots, echo=TRUE, warning=FALSE}
autoplot(fit1)
```

```{r lm_model, echo=TRUE, warning=FALSE}
# Best result at 60 days -- y ~ x
x_value2 = df_BTCTSLA_lag_m$TSLA_lag_60
y_value2 = df_BTCTSLA_lag_m$BTC.USD.Close
fit2 = lm(data = df_BTCTSLA_lag_m, y_value2 ~ x_value2)
summary(fit2)
ggplot(df_BTCTSLA_lag_m, aes(x = x_value2, y = y_value2)) +
  geom_point() +
  xlab("TSLA 60 days lag") + 
  ylab("Bitcoin closing") + 
  stat_smooth(method = 'lm', col = 'red') + 
  labs(title = paste("Adj R2=", signif(summary(fit2)$adj.r.squared, 5),
                     "Inc=", signif(fit2$coef[[1]], 5),
                     "Slp=", signif(fit2$coef[[2]], 5),
                     #"P=", signif(summary(fit2)$coef[2,4], 5)
                     "RSE=", sigma(fit2)/mean(df_BTCTSLA_lag_m$BTC.USD.Close, na.rm=TRUE)))
```
```{r lm_model_plots, echo=TRUE, warning=FALSE}
autoplot(fit2)
```

```{r lm_model_return, echo=TRUE, warning=FALSE}
x_value3 = df_BTCTSLA_lag_m$TSLA_Return
y_value3 = df_BTCTSLA_lag_m$BTC_Return
fit3 = lm(data = df_BTCTSLA_lag_m, y_value3 ~ x_value3)
summary(fit3)
ggplot(df_BTCTSLA_lag_m, aes(x = x_value3, y = y_value3)) +
  geom_point() +
  xlab("TSLA return") + 
  ylab("Bitcoin return") + 
  stat_smooth(method = 'lm', col = 'red') + 
  labs(title = paste("Adj R2=", signif(summary(fit3)$adj.r.squared, 5),
                     "Inc=", signif(fit3$coef[[1]], 5),
                     "Slp=", signif(fit3$coef[[2]], 5),
                     #"P=", signif(summary(fit3)$coef[2,4], 5),
                     "RSE=", sigma(fit3)/mean(df_BTCTSLA_lag_m$BTC.USD.Close, na.rm=TRUE)))
```
```{r lm_model_return_plots, echo=TRUE, warning=FALSE}
autoplot(fit3)
```
```{r correlation_matrix, warning=FALSE}
library(corrplot)
df_BTCTSLA_cor <- cor(subset(df_BTCTSLA_lag_m, select = -c(date)), use="pairwise.complete.obs")
corrplot(df_BTCTSLA_cor, method="pie")
corrplot(df_BTCTSLA_cor, method="number")
```

```{r others}
# coins data frame
df_coin = data.frame()
df_coin = merge(df_BTC, df_ETH, by = 'date', all.x = TRUE)
df_coin = merge(df_coin, df_ADA, by = 'date', all.x = TRUE)
df_coin = merge(df_coin, df_DOGE, by = 'date', all.x = TRUE)
df_coin = merge(df_coin, df_SHIB, by = 'date', all.x = TRUE)
# indexes data frame
df_index = data.frame()
df_index = merge(df_DJI, df_IXIC, by = 'date', all.x = TRUE)
df_index = merge(df_index, df_GSPC, by = 'date', all.x = TRUE)
df_index = merge(df_index, df_GOLD, by = 'date', all.x = TRUE)
# stocks data frame
df_stock = data.frame()
df_stock = merge(df_TSLA, df_GOOG, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_AAPL, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_NVDA, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_AMD, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_TSM, by = 'date', all.x = TRUE)
# merge 3 portfolios data frame
df_port = data.frame()
df_port = merge(df_coin, df_index, by = 'date', all.x = TRUE)
df_port = merge(df_port, df_stock, by = 'date', all.x = TRUE)

# subset 2019
df_port <- subset(df_port,
                  date >= '2019-01-01',
                  select = c(date, 
                             BTC.USD.Close, 
                             BTC.USD.Volume,
                             ETH.USD.Close, 
                             ETH.USD.Volume,
                             ADA.USD.Close, 
                             ADA.USD.Volume,
                             DOGE.USD.Close, 
                             DOGE.USD.Volume,
                             SHIB.USD.Close, 
                             SHIB.USD.Volume,
                             DJI.Close, 
                             DJI.Volume,
                             IXIC.Close, 
                             IXIC.Volume,
                             GSPC.Close, 
                             GSPC.Volume,
                             GC.F.Close, 
                             GC.F.Volume,
                             TSLA.Close, 
                             TSLA.Volume,
                             GOOG.Close, 
                             GOOG.Volume,
                             AAPL.Close, 
                             AAPL.Volume,
                             NVDA.Close, 
                             NVDA.Volume,
                             AMD.Close, 
                             AMD.Volume,
                             TSM.Close, 
                             TSM.Volume
                             ))
row.names(df_port) <- NULL
```

```{r multi_linear}
m_fit <- lm(`BTC.USD.Close` ~ . -date,
            data = df_port)
summary(m_fit)
```

```{r multi_linear_stars}
m_fit_adjusted <- lm(`BTC.USD.Close` ~ 
                       `BTC.USD.Volume` + 
                       `ETH.USD.Close` + 
                       `ETH.USD.Volume` + 
                       `DOGE.USD.Close` +
                       `GC.F.Close`,
                     data = df_port)
summary(m_fit_adjusted)
# R squared
signif(summary(m_fit_adjusted)$adj.r.squared, 5)
```
```{r multi_linear_stars_f}
m_fit_adjusted_filtered <- lm(`BTC.USD.Close` ~ 
                                `BTC.USD.Volume` +
                                `ETH.USD.Close` + 
                                `DOGE.USD.Close`,
                              data = df_port)
summary(m_fit_adjusted_filtered)
# R squared
signif(summary(m_fit_adjusted_filtered)$adj.r.squared, 5)
```


```{r SLR_sets}
df_port_training <- df_port %>% slice(1:(length(df_port$BTC.USD.Close)*0.7))
df_port_training
df_port_test <- df_port %>% slice(ceiling(length(df_port$BTC.USD.Close)*0.7):length(df_port$BTC.USD.Close))
```

```{r SLR_sampling}
# sampling from training and test sets with 80% relative of their sets
trainset_size <- floor(0.8 * nrow(df_port_training))
testset_size <- floor(0.8 * nrow(df_port_test))
set.seed(2)
trainset_indices <- sample(seq_len(nrow(df_port_training)), size = trainset_size)
testset_indices <- sample(seq_len(nrow(df_port_test)), size = testset_size)
trainset <- df_port_training[trainset_indices, ]
testset <- df_port_test[testset_indices, ]
```

```{r SLR_TSLA_modelling}
lm_TSLA = lm(formula = BTC.USD.Close ~ TSLA.Close, data = trainset)
summary(lm_TSLA)
```

```{r SLR_TSLA_RSE}
# Residual Standard Error
sigma(lm_TSLA)/mean(trainset$BTC.USD.Close, na.rm=TRUE)
```
#abc
```{r SLR_TSLA_RMSE}
library(Metrics)

```