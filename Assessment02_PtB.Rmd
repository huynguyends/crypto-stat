---
title: "Assessment02_pt_b"
author: "Xilin Huang Liam"
date: "20/09/2021"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading data from Yahoo Finance
Before we starting working on building models and analysis, data need to be loaded from Yahoo Finance API. In our project, we will be collecting:

Coins (to US dollar)

* BTC-USD: Bitcoin

* ETH-USD: Ethereum

* ADA-USD: Cardano

* DOGE-USD: Dogecoin

* SHIB-USD: Shiba Inu coin

Index

* ^DJI: Dow Jones Industrial

* ^IXIC: Nasdaq Composite

* ^GSPC: S&P 500

* GC=F: Gold

Stocks

* TSLA: Tesla

* GOOG: Google

* AAPL: Apple

* NVDA: Nvidia

* AMD: Advanced Micro Devices

* TSM: Taiwan Semiconductor Manufacturing

All the data will be saved as `xts` (Extensible Time Series) object.

```{r yahoo, message=FALSE, warning=FALSE}
rm(list=ls())
library(zoo)
library(xts)
library(TTR)
library(quantmod)

coin_portfolio=c("BTC-USD","ETH-USD","ADA-USD",
                 "DOGE-USD","SHIB-USD")
index_portfolio=c("^DJI","^IXIC","^GSPC","GC=F")
stock_portfolio=c("TSLA","GOOG","AAPL","NVDA","AMD","TSM")

data <- getSymbols(c(coin_portfolio,
                     index_portfolio,
                     stock_portfolio),
                   src='yahoo',
                   from="2019-12-08",
                   #to=d,
                   autoassign=FALSE)
```

## Simple linear regression in finance data
For simple linear regression, we will use TSLA - Bitcoin as example. Since this project will be focusing on performing linear regression models, the data will be transformed from `xts` object to `dataframe`. Other data will be transformed to dataframes for multi-linear model analysis based on the result of TSLA - Bitcoin.

```{r data}
df_BTC = data.frame(date=index(`BTC-USD`), coredata(`BTC-USD`))
df_TSLA = data.frame(date=index(TSLA), coredata(TSLA))
# coins
df_ETH = data.frame(date=index(`ETH-USD`), coredata(`ETH-USD`))
df_ADA = data.frame(date=index(`ADA-USD`), coredata(`ADA-USD`))
df_DOGE = data.frame(date=index(`DOGE-USD`), coredata(`DOGE-USD`))
df_SHIB = data.frame(date=index(`SHIB-USD`), coredata(`SHIB-USD`))
# indexs
df_DJI = data.frame(date=index(DJI), coredata(DJI))
df_IXIC = data.frame(date=index(IXIC), coredata(IXIC))
df_GSPC = data.frame(date=index(GSPC), coredata(GSPC))
df_GOLD = data.frame(date=index(`GC=F`), coredata(`GC=F`))
# stock
df_GOOG = data.frame(date=index(GOOG), coredata(GOOG))
df_AAPL = data.frame(date=index(AAPL), coredata(AAPL))
df_NVDA = data.frame(date=index(NVDA), coredata(NVDA))
df_AMD = data.frame(date=index(AMD), coredata(AMD))
df_TSM = data.frame(date=index(TSM), coredata(TSM))
```

```{r friday_filled, message=FALSE, warning=FALSE}
library(tidyr)
# use Friday's data for weekends
df_sub <- merge(df_BTC, df_ETH, by = 'date', all.x = TRUE)
df_sub <- merge(df_sub, df_IXIC, by = 'date', all.x = TRUE)
df_sub <- merge(df_sub, df_GOLD, by = 'date', all.x = TRUE)
df_sub <- merge(df_sub, df_TSM, by = 'date', all.x = TRUE)

#df_sub_filled <- df_sub %>% fill()
```

```{r 2019, message=FALSE, warning=FALSE}
# subset data (close price)
df_sub <- subset(na.omit(df_sub),
                 #date >= '2019-01-01',
                 select = c(date,
                            BTC.USD.Close,
                            ETH.USD.Close,
                            GC.F.Close,
                            IXIC.Close,
                            TSM.Close
                            )
                 )
row.names(df_sub) <- NULL
```

```{r lag_data, message=FALSE, warning=FALSE}
library(dplyr)
lag_list = c(1, 5, 10, 20, 40, 60) # needs research

for (i in lag_list){
  if (i == lag_list[1]) {
    df_BTC_TDlag = data.frame(col1 = lag(df_sub$BTC.USD.Close, n = i))
    names(df_BTC_TDlag)[ncol(df_BTC_TDlag)] <- paste0("BTC_TDlag_", i)
  } else {
    df_BTC_TDlag[,ncol(df_BTC_TDlag)+1] <- lag(df_sub$BTC.USD.Close, n = i)
    names(df_BTC_TDlag)[ncol(df_BTC_TDlag)] <- paste0("BTC_TDlag_", i)
  }
}

for (i in lag_list){
  if (i == lag_list[1]) {
    df_ETH_TDlag = data.frame(col1 = lag(df_sub$ETH.USD.Close, n = i))
    names(df_ETH_TDlag)[ncol(df_ETH_TDlag)] <- paste0("ETH_TDlag_", i)
  } else {
    df_ETH_TDlag[,ncol(df_ETH_TDlag)+1] <- lag(df_sub$ETH.USD.Close, n = i)
    names(df_ETH_TDlag)[ncol(df_ETH_TDlag)] <- paste0("ETH_TDlag_", i)
  }
}

for (i in lag_list){
  if (i == lag_list[1]) {
    df_IXIC_TDlag = data.frame(col1 = lag(df_sub$IXIC.Close, n = i))
    names(df_IXIC_TDlag)[ncol(df_IXIC_TDlag)] <- paste0("IXIC_TDlag_", i)
  } else {
    df_IXIC_TDlag[,ncol(df_IXIC_TDlag)+1] <- lag(df_sub$IXIC.Close, n = i)
    names(df_IXIC_TDlag)[ncol(df_IXIC_TDlag)] <- paste0("IXIC_TDlag_", i)
  }
}

for (i in lag_list){
  if (i == lag_list[1]) {
    df_GOLD_TDlag = data.frame(col1 = lag(df_sub$GC.F.Close, n = i))
    names(df_GOLD_TDlag)[ncol(df_GOLD_TDlag)] <- paste0("GOLD_TDlag_", i)
  } else {
    df_GOLD_TDlag[,ncol(df_GOLD_TDlag)+1] <- lag(df_sub$GC.F.Close, n = i)
    names(df_GOLD_TDlag)[ncol(df_GOLD_TDlag)] <- paste0("GOLD_TDlag_", i)
  }
}

for (i in lag_list){
  if (i == lag_list[1]) {
    df_TSM_TDlag = data.frame(col1 = lag(df_sub$TSM.Close, n = i))
    names(df_TSM_TDlag)[ncol(df_TSM_TDlag)] <- paste0("TSM_TDlag_", i)
  } else {
    df_TSM_TDlag[,ncol(df_TSM_TDlag)+1] <- lag(df_sub$TSM.Close, n = i)
    names(df_TSM_TDlag)[ncol(df_TSM_TDlag)] <- paste0("TSM_TDlag_", i)
  }
}
```

```{r lag_data_merge, echo=TRUE}
df_selected <- cbind(df_sub, df_BTC_TDlag)
df_selected <- cbind(df_selected, df_ETH_TDlag)
df_selected <- cbind(df_selected, df_IXIC_TDlag)
df_selected <- cbind(df_selected, df_GOLD_TDlag)
df_selected <- cbind(df_selected, df_TSM_TDlag)
```

```{r return_data, echo=TRUE, message=FALSE}
# Bitcoin daily return
BDReturn <- c(NA, diff(df_selected$BTC.USD.Close)/df_selected$BTC.USD.Close*100)
BDReturn <- BDReturn[-length(BDReturn)]
df_selected$BTC_Return <- BDReturn
```

```{r lm_model_log, echo=TRUE, warning=FALSE}
library(ggplot2)
library(ggfortify)
# Best result at 90 lag days -- log(y) ~ x
x_value1 = log(df_selected$ETH_TDlag_1)
y_value1 = log(df_selected$BTC.USD.Close)
fit1 = lm(data = df_selected, y_value1 ~ x_value1)
summary(fit1)
ggplot(df_selected, aes(x = x_value1, y = y_value1)) +
  geom_point() +
  xlab("log ETH 1 trading days lag") + 
  ylab("log Bitcoin closing") + 
  stat_smooth(method = 'lm', col = 'red') + 
  labs(title = paste("Adj R2=", signif(summary(fit1)$adj.r.squared, 5),
                     "Inc=", signif(fit1$coef[[1]], 5),
                     "Slp=", signif(fit1$coef[[2]], 5),
                     "P=", signif(summary(fit1)$coef[2,4], 5)
                     )
       )
```
```{r lm_model_log_plots, echo=TRUE, warning=FALSE}
autoplot(fit1)
```

```{r correlation_matrix, warning=FALSE}
library(corrplot)
df_selected_cor <- cor(subset(df_selected, select = -c(date, 
                                                       BTC_TDlag_1,
                                                       BTC_TDlag_5,
                                                       BTC_TDlag_10,
                                                       BTC_TDlag_20,
                                                       BTC_TDlag_40,
                                                       BTC_TDlag_60)
                              ),
                       use="pairwise.complete.obs")
#corrplot(df_selected_cor, method="pie")
corrplot(df_selected_cor, method="number")
```

```{r others}
# coins data frame
df_coin = data.frame()
df_coin = merge(df_BTC, df_ETH, by = 'date', all.x = TRUE)
df_coin = merge(df_coin, df_ADA, by = 'date', all.x = TRUE)
df_coin = merge(df_coin, df_DOGE, by = 'date', all.x = TRUE)
df_coin = merge(df_coin, df_SHIB, by = 'date', all.x = TRUE)
# indexes data frame
df_index = data.frame()
df_index = merge(df_DJI, df_IXIC, by = 'date', all.x = TRUE)
df_index = merge(df_index, df_GSPC, by = 'date', all.x = TRUE)
df_index = merge(df_index, df_GOLD, by = 'date', all.x = TRUE)
# stocks data frame
df_stock = data.frame()
df_stock = merge(df_TSLA, df_GOOG, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_AAPL, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_NVDA, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_AMD, by = 'date', all.x = TRUE)
df_stock = merge(df_stock, df_TSM, by = 'date', all.x = TRUE)
# merge 3 portfolios data frame
df_port = data.frame()
df_port = merge(df_coin, df_index, by = 'date', all.x = TRUE)
df_port = merge(df_port, df_stock, by = 'date', all.x = TRUE)

# subset
df_port <- subset(df_port,
                  #date >= '2019-01-01',
                  select = c(date, 
                             BTC.USD.Close, 
                             BTC.USD.Volume,
                             ETH.USD.Close, 
                             ETH.USD.Volume,
                             ADA.USD.Close, 
                             ADA.USD.Volume,
                             DOGE.USD.Close, 
                             DOGE.USD.Volume,
                             SHIB.USD.Close, 
                             SHIB.USD.Volume,
                             DJI.Close, 
                             DJI.Volume,
                             IXIC.Close, 
                             IXIC.Volume,
                             GSPC.Close, 
                             GSPC.Volume,
                             GC.F.Close, 
                             GC.F.Volume,
                             TSLA.Close, 
                             TSLA.Volume,
                             GOOG.Close, 
                             GOOG.Volume,
                             AAPL.Close, 
                             AAPL.Volume,
                             NVDA.Close, 
                             NVDA.Volume,
                             AMD.Close, 
                             AMD.Volume,
                             TSM.Close, 
                             TSM.Volume
                             )
                  )
row.names(df_port) <- NULL


df_port_price <- subset(df_port,
                        select = c(date, 
                                   BTC.USD.Close, 
                                   ETH.USD.Close, 
                                   ADA.USD.Close, 
                                   DOGE.USD.Close, 
                                   SHIB.USD.Close, 
                                   DJI.Close,                       
                                   IXIC.Close, 
                                   GSPC.Close, 
                                   GC.F.Close, 
                                   TSLA.Close, 
                                   GOOG.Close, 
                                   AAPL.Close, 
                                   NVDA.Close, 
                                   AMD.Close, 
                                   TSM.Close
                                   )
                        )

df_port_price_cor <- cor(subset(df_port_price, select = -c(date)), use="pairwise.complete.obs")
corrplot(df_port_price_cor, method="number")
```

```{r multi_linear}
#m_fit <- lm(`BTC.USD.Close` ~ . -date,
#            data = df_port_price)
#summary(m_fit)
```

```{r multi_linear_stars}
#m_fit_adjusted <- lm(`BTC.USD.Close` ~ 
#                       `BTC.USD.Volume` + 
#                       `ETH.USD.Close` + 
#                       `ETH.USD.Volume` + 
#                       `DOGE.USD.Close` +
#                       `GC.F.Close`,
#                     data = df_port)
#summary(m_fit_adjusted)
# R squared
#signif(summary(m_fit_adjusted)$adj.r.squared, 5)
```
```{r multi_linear_stars_f}
#m_fit_adjusted_filtered <- lm(`BTC.USD.Close` ~ 
#                                `BTC.USD.Volume` +
#                                `ETH.USD.Close` + 
#                                `DOGE.USD.Close`,
#                              data = df_port)
#summary(m_fit_adjusted_filtered)
# R squared
#signif(summary(m_fit_adjusted_filtered)$adj.r.squared, 5)
```

```{r SLR_sampling}
# sampling train, validation and test sets (if using stepwise this step could be ignored)
trainset_size <- floor(0.7 * nrow(df_port_price))
validation_size <- floor(0.1 * nrow(df_port_price))
testset_size <- floor(0.2 * nrow(df_port_price))
set.seed(2)
trainset_indices <- sample(seq_len(nrow(df_port_price)), size = trainset_size)
trainset <- df_port_price[trainset_indices, ]
df_set <- df_port_price[-trainset_indices, ]
testset_indices <- sample(seq_len(nrow(df_set)), size = testset_size)
testset <- df_set[testset_indices, ]
validationset <- df_set[-testset_indices,]
```

```{r SLR_TSLA_modelling}
lm_TSLA = lm(formula = BTC.USD.Close ~ TSLA.Close, data = trainset)
summary(lm_TSLA)

testset_selected <- subset(testset, select=c(TSLA.Close,
                                             BTC.USD.Close))
ggplot(trainset, aes(x=TSLA.Close, y=BTC.USD.Close)) + 
  geom_point() + 
  geom_point(data=testset_selected,colour='red') + 
  stat_smooth(method = 'lm', col = 'black') 
```

```{r stepwise_leaps}
#library(leaps)
#models <- regsubsets(BTC.USD.Close ~.,
#                     data = subset(trainset, select=-(date)),
#                     nvmax = 8,
#                     method = "seqrep")
#summary(models)
```
```{r cor}
df_selected_cor <- cor(subset(df_selected, select = -c(date,
#                                                    BTC_TDlag_1,
#                                                    BTC_TDlag_5,
#                                                    BTC_TDlag_10, 
#                                                    BTC_TDlag_20,
#                                                    BTC_TDlag_40,
#                                                    BTC_TDlag_60,
                                                    ETH.USD.Close,
                                                    IXIC.Close,
                                                    GC.F.Close,
                                                    TSM.Close,
                                                    BTC_Return)), use="pairwise.complete.obs")
corrplot(df_selected_cor,method="number")
```
```{r stepwise_caret}
library(caret)
train.control <- trainControl(method = "cv", number = 5, p = 0.7)
df_selected_test <- df_selected[df_selected['date'] >= '2021-09-01',]
df_selected_train <- df_selected[df_selected['date'] < '2021-09-01',]
# use the data without volume
step.model <- train(BTC.USD.Close ~.,
                    data = na.omit(subset(df_selected_train,
                                          select=c(BTC.USD.Close,
                                                   BTC_TDlag_1,
                                                   ETH_TDlag_1,
                                                   IXIC_TDlag_5,
                                                   GOLD_TDlag_60,
                                                   TSM_TDlag_40)
                                         )
                                 ),
                    method = "leapSeq",#"leapBackward", #"leapSeq", #"leapForward",
                    tuneGrid = data.frame(nvmax = 1:5),
                    trControl = train.control
                    )

step.model
summary(step.model$finalModel)
step.model$bestTune
#step.model$bestTune
coef(step.model$finalModel, 3)

besttune_lm <- train(BTC.USD.Close ~. -IXIC_TDlag_5 -GOLD_TDlag_60,
                    data = na.omit(subset(df_selected_train,
                                          select=c(BTC.USD.Close,
                                                   BTC_TDlag_1,
                                                   ETH_TDlag_1,
                                                   IXIC_TDlag_5,
                                                   GOLD_TDlag_60,
                                                   TSM_TDlag_40)
                                         )
                                   ),
                    method = "lm",
                    trControl = train.control
                    )
coef(besttune_lm$finalModel)
car::vif(besttune_lm$finalModel) #greedy algorithm

deviance(besttune_lm$finalModel) #compare SSE every elimination

summary(besttune_lm)

prediction <- predict(besttune_lm$finalModel, df_selected_test)
# RMSE
RMSE = sqrt(mean((prediction - df_selected_test$BTC.USD.Close)^2, na.rm = TRUE))

RMSE/(mean(df_selected_test$BTC.USD.Close))

autoplot(besttune_lm$finalModel)
```
                                          select=-c(date,
                                                    BTC_TDlag_1,
                                                    BTC_TDlag_5,
                                                    BTC_TDlag_10, 
                                                    BTC_TDlag_20,
                                                    BTC_TDlag_40,
                                                    BTC_TDlag_60,
                                                    ETH.USD.Close,
                                                    IXIC.Close,
                                                    GC.F.Close,
                                                    TSM.Close,
                                                    BTC_Return
                                                   )
```{r elimination}
besttune_lm <- train(BTC.USD.Close ~ ETH_TDlag_1 + 
                       ETH_TDlag_10 + 
                       ETH_TDlag_20 +
                       ETH_TDlag_60 +
                       GOLD_TDlag_20 +
                       TSM_TDlag_20 +
                       TSM_TDlag_40 +
                       TSM_TDlag_60,
                    data = na.omit(df_selected_train),
                    method = "lm",
                    trControl = train.control
                    )
coef(besttune_lm$finalModel)

car::vif(besttune_lm$finalModel) #greedy algorithm

deviance(besttune_lm$finalModel) #compare SSE every elimination
```


# Not in used
```{r stepwise_MASS}
library(MASS)
full.model <- lm(BTC.USD.Close ~., data = na.omit(subset(df_selected,
                                                         select=-c(date,
                                                                   BTC_TDlag_1,
                                                                   BTC_TDlag_5,
                                                                   BTC_TDlag_10,
                                                                   BTC_TDlag_20,
                                                                   BTC_TDlag_40,
                                                                   BTC_TDlag_60)
                                                         )
                                                  )
)
step.model <- stepAIC(full.model, direction = "both", 
                      trace = FALSE)
summary(step.model)
```

```{r stepwise_MASS_caret}
# Train the model
step.model <- train(BTC.USD.Close ~., data = na.omit(trainset),
                    method = "lmStepAIC", 
                    trControl = train.control,
                    trace = FALSE
                    )
# Model accuracy
step.model$results
# Final model coefficients
step.model$finalModel
# Summary of the model
summary(step.model$finalModel)
```

